<!DOCTYPE HTML>

<html>
   <head>
      <title>Circular Snake</title>

      <link href="https://fonts.googleapis.com/css?family=Varela+Round" rel="stylesheet">

      <style>
			body {
				background-color: #202020;
				height: 100%;
				width: 100%;
				background-attachment: fixed;
			}

			#canvas:-webkit-full-screen { background-color: rgba(255,255,255,0); }

			#canvas {
				margin: auto; position: absolute;
				top: 0; bottom: 0; right: 0; left: 0;
			}
      </style>

      <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

      <script>
         // PARAMETERS

         //////////////////////////
			// Graphics parameters  //
			//////////////////////////

         //Radius factor: field radius = canvas.height * radiusFactor
			var radiusFactor = 0.38;

         // Radius of snake points
         var snakePointRadius = 9;

         //Field color: the background color of the circular game field
			var fieldColor = "#303030";

         // Obstacle color
         var obstColor = "";

         // Fruit color
         var fruitColor = "#FCFFA3";

         //Width of the screen shake effect
			var screenshakeWidth = 3;

         // Score text color
         var scoreColor = "#FCFFA3";

         // Score text size
         var scoreSize = 80;
         var bestScoreSize = 24;

         //////////////////////////
			// Game parameters      //
			//////////////////////////

         var fruitRadius = snakePointRadius;

         // Snake base speed, in pixels per second
         var snakeBaseSpeed = 80;

         // Maximum speed factor
         var maxSpeedFactor = 3;
         var logMSF = Math.log ( maxSpeedFactor - 1 );

         // Speed increase parameter
         var speedIncreaseParam = 0.001;

          // Snake curve radius, in pixels
         var snakeRotateRadius = 35;

         // Rotation speed, in radians per second
         var snakeRotateSpeed = snakeBaseSpeed / snakeRotateRadius;

         // Length gained for each fruit
         var fruitLength = 20;

         // Snake initial length, in snake points
         var snakeInitialLength = 50;

         // Scaling parameters
         var initialScaling = 1.75;
         var minScaling = 0.5;
         var scalingK = 0.05;

         // Combo duration, seconds
         var comboDuration = 4;
      </script>

      <script>
         var outElastic = function(t) {
             var s = 1.70158;
             var p = 0;
             var a = 1;
             if (t == 0) return 0;
             if (t == 1) return 1;
             if (!p) p = 0.3;
             if (a < 1) {
               a = 1;
               s = p / 4;
             } else s = p / (2 * Math.PI) * Math.asin(1 / a);
             return a * Math.pow(2, -15 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
         }

         var canvas = 0, context = 0;
         var fps = 60;

         var radius = 0;

         var dist = function ( a, b ) {
            var dx = a[0] - b[0];
            var dy = a[1] - b[1];
            return Math.sqrt ( dx*dx + dy*dy );
         }

         var dist2 = function ( a, b ) {
            var dx = a[0] - b[0];
            var dy = a[1] - b[1];
            return dx*dx + dy*dy;
         }

         var Snake = function () {
            // Color of the snake
            this.color = "#FF6000";

            // Array of the positions of the extremes of the segments of the
            // snake; it is an array of arrays of two elements each, x and y
            // coordinates of the point, relative to the center of the field
            this.positions = [ ];

            // Snake direction : defined as an angle in radians from PI to -PI
            this.direction = 0;
            this.rotate = -1;

            // Snake base speed, in pixels per second
            this.speed = snakeBaseSpeed;

            // Function that moves the snake for the requested time step
            this.move = function ( t ) {
               var dx = this.speed * t;
               var r = snakePointRadius; //0.5 * snakePointRadius * ( 1 + Math.exp ( -0.0005 * (this.positions.length-snakeInitialLengt ) );

               this.positions.unshift ( this.positions[0].slice(0) );
               this.positions[0][0] += dx * Math.cos ( this.direction );
               this.positions[0][1] += dx * Math.sin ( this.direction );
               this.positions[0][2] = r;

               this.positions.splice(-1,1);

               this.direction += snakeRotateSpeed * this.rotate * t;
            }

            // Function that grows the snake by one element
            this.grow = function ( k ) {
               for ( var i = 0; i < k; ++i ) {
                  this.positions.push(this.positions[this.positions.length-1].slice(0));
               }
            }

            // Plays eat animation effect
            this.eat = function () {
               this.grow ( fruitLength );
            }

            // Function that draws the snake on a graphic context
            this.draw = function ( context ) {
               context.fillStyle = this.color;

               for ( var i = 0; i < this.positions.length; i++ ) {
                  context.beginPath ();
                  context.arc ( this.positions[i][0], this.positions[i][1], this.positions[i][2], 0, 2*Math.PI );
                  context.fill ();
               }

               context.fillStyle = fieldColor;
               context.beginPath ();
               context.arc ( this.positions[0][0], this.positions[0][1], this.positions[0][2]*0.6, 0, 2*Math.PI );
               context.fill();
            }
         }

         var Match = function ( ) {
            // Game running flag
            this.running = false;

            // Match snake
            this.snake = new Snake ( );

            // Current fruit position
            // Coordinates relative to field center
            this.fruits = [ [0,0] ];

            // Score
            this.score = 0;
            this.scoreNoCombo = 0;
            this.scoreShow = 0;
            this.combo = 0;
            this.comboTime = 0;
            this.combometerShow = 0;

            // Obstacles
            this.obstacles = [];

            // Time
            this.t = 0;
            this.targetScaling = initialScaling;
            this.scaling = initialScaling;

            // Last time of obstacle spawn
            this.lastObst = 0;

            // Function that sets up the game
            this.setup = function ( ) {
               this.snake = new Snake ( );
               this.obstacles = [];
               this.snake.positions.push ( [0,snakeRotateRadius,snakePointRadius] );
               this.snake.grow ( snakeInitialLength );
               this.fruits = [];

               var d = 10;
               for ( var i = 0; i < 10; ++i ) {
                  this.spawnFruit ( i+1, d );
                  d *= 2;
               }

               this.score = 0;
               this.scoreShow = 0;
               this.scoreNoCombo = 0;
               this.combo = 0;
               this.comboTime = 0;
               this.running = true;
               this.t = 0;
               this.scaling = initialScaling;
               this.targetScaling = initialScaling;

               this.spawnFruit ( 0 );

               this.lastObst = 0;
            }

            // Function that draws the game
            this.draw = function ( context ) {
               context.fillStyle = fieldColor;
   				context.beginPath();
   				context.arc ( 0, 0, radius, 0, 2 * Math.PI );
   				context.fill();

               context.save ();
               context.scale ( this.scaling, this.scaling );
               this.snake.draw ( context );

               context.fillStyle = obstColor;
               for ( var i = 0; i < this.obstacles.length; ++i ) {
                  context.beginPath ( );
                  context.arc ( this.obstacles[i][0], this.obstacles[i][1], this.obstacles[i][2], 0, 2*Math.PI );
                  context.fill();
               }

               context.fillStyle = fruitColor;
               for ( var i = 0; i < this.fruits.length; ++i ) if ( this.fruits[i][3] <= 0 ) {
                  context.beginPath();
                  context.arc ( this.fruits[i][0], this.fruits[i][1], this.fruits[i][2], 0, 2*Math.PI );
                  context.fill();
               }

               context.restore();

               if ( this.combo > 0 ) {
                  context.lineCap = "round";
                  context.strokeStyle = fruitColor;
                  context.lineWidth = 10;
                  context.beginPath();
                  context.arc ( 0, 0, radius + 5, -Math.PI * this.combometerShow, Math.PI * this.combometerShow );
                  context.stroke();
               }
            }

            // Function that updates the game
            this.update = function ( t ) {
               if ( !this.running ) return;

               this.t += t;

               var oldPositions = [];
               for ( var i = 0; i < this.snake.positions.length; ++i )
                  oldPositions.push ( this.snake.positions[i].slice(0) );

               this.snake.move ( t * ( maxSpeedFactor - Math.exp( -speedIncreaseParam * this.scoreNoCombo + logMSF ) ) );

               // Check if the snake has hit some fruit
               var r = fruitRadius + snakePointRadius;
               for ( var i = 0; i < this.fruits.length; ++i ) {
                  if ( this.fruits[i][3] <= 0 && dist2 ( this.snake.positions[0], this.fruits[i] ) < r*r ) {
                     this.score += 1 + this.combo;
                     this.scoreNoCombo++;

                     localStorage.bestScore = Math.max ( localStorage.bestScore, this.score );
                     this.spawnFruit(i);
                     this.snake.eat();

                     this.targetScaling = minScaling + ( initialScaling - minScaling ) * Math.exp ( -this.scoreNoCombo * scalingK );

                     this.combo += 1;
                     this.comboTime = this.t;
                  }
               }

               // Check if the snake has hit the border
               r = radius / this.scaling - this.snake.positions[0][2] + 1;
               if ( dist2 ( this.snake.positions[0], [0,0] ) > r*r )
                  this.running = false;

               // Check if the snake has hit some parts of itself
               r = 2*snakePointRadius-1;
               for ( var i = 11; i < this.snake.positions.length; ++i )
                  if ( dist2 ( this.snake.positions[0], this.snake.positions[i] ) < r*r &&
                       dist2 ( oldPositions[0], oldPositions[i] ) >= r*r )
                     this.running = false;

               // Check if the snake has hit some obstacle
               for ( var i = 0; i < this.obstacles.length; ++i ) {
                  r = snakePointRadius + this.obstacles[i][2] - 1;
                  if ( dist2 ( this.snake.positions[0], this.obstacles[i] ) < r*r )
                     this.running = false;
               }

               // Spawn obstacles
               if ( Math.random() * 10000 < this.t - this.lastObst ) {
                  this.spawnObst();
                  this.lastObst = this.t;
               }

               // Combo timer
               if ( this.t - this.comboTime > comboDuration ) {
                  this.combo = 0;
               }
               else {
                  targetCombometer = 1 - (this.t - this.comboTime) / comboDuration;
                  this.combometerShow += ( targetCombometer - this.combometerShow ) * 20 * t;
               }

               // Animate scaling
               this.scaling += (this.targetScaling - this.scaling) * t * 5;

               // Animate score
               this.scoreShow += (this.score - this.scoreShow) * 10 * t;

               // Animate obstacles
               for ( var i = 0; i < this.obstacles.length; ++i ) {
                  var x = (this.t - this.obstacles[i][4]);
                  this.obstacles[i][2] = this.obstacles[i][3] * outElastic(x);
               }

               // Animate fruit
               for ( var i = 0; i < this.fruits.length; ++i ) {
                  if ( this.fruits[i][3] <= 0 ) this.fruits[i][2] += ( fruitRadius - this.fruits[i][2] ) * t * 10;
                  else { this.fruits[i][3] -= t; if ( this.fruits[i][3] <= 0 ) this.spawnFruit(i); }
               }

               if ( !this.running ) shake();
            }

            // Spawns a fruit in the game
            this.spawnFruit = function ( j, delay ) {
               if ( delay == undefined ) delay = 0;

               if ( j == undefined || this.fruits.length <= j) {
                  this.fruits.push ( [0,0,0,0] );
                  j = this.fruits.length - 1;
               }

               var r = Math.random() * (radius / this.scaling - fruitRadius - 5);
               var th = Math.random() * 2*Math.PI;

               this.fruits[j][0] = r * Math.cos(th);
               this.fruits[j][1] = r * Math.sin(th);
               this.fruits[j][2] = 0;
               this.fruits[j][3] = delay;

               if ( delay > 0 ) return;

               for ( var i = 0; i < this.obstacles.length; ++i ) {
                  var rr = fruitRadius + ( this.obstacles[i][2] + 5 );
                  if ( dist2 ( this.fruits[j], this.obstacles[i] ) < rr*rr ) {
                     this.spawnFruit(j,delay);
                     break;
                  }
               }

               var rr = fruitRadius + snakePointRadius + 10;
               for ( var k = 0; k < this.snake.positions.length; k++ ) {
                  if ( dist2 ( this.fruits[j], this.snake.positions[k] ) < rr*rr ) {
                     this.spawnFruit(j,delay);
                     break;
                  }
               }

               var rr = 2 * fruitRadius + 30;
               for ( var i = 0; i < this.fruits.length; ++i ) {
                  if ( i != j && dist2 ( this.fruits[j], this.fruits[i] ) < rr*rr ) {
                     this.spawnFruit(j,delay);
                     break;
                  }
               }
            }

            // Spawns an obstacle
            this.spawnObst = function () {
               var r, rho, th, obst;
               var again;

               do {
                  rho = Math.random() * radius / this.scaling;
                  r = ( Math.random() * 50 + 30 ) / this.scaling;;
                  th = Math.random() * 2*Math.PI;
                  obst = [ rho * Math.cos(th), rho * Math.sin(th), 0, r, this.t ];

                  again = ( dist2 ( this.snake.positions[0], obst ) < (r + snakePointRadius + snakeRotateRadius)*(r + snakePointRadius + snakeRotateRadius) );

                  // Also check that the obstacle doesn't cover any fruit
                  for ( var i = 0; i < this.fruits.length && !again; ++i )
                     again = ( dist2 ( this.fruits[i], obst ) < (r + fruitRadius)*(r + fruitRadius) );

                  // And also check that it doesn't cover the tail
                  for ( var i = 0; i < this.snake.positions.length && !again; ++i )
                     again = ( dist2 ( this.snake.positions[i], obst ) < (r + snakePointRadius)*(r + snakePointRadius) );
               } while ( again );

               this.obstacles.push ( obst );
            }
         }

         var match = new Match ();

         var screenshake = 0;
			var screenshakeBegin = -1;
         var shake = function () { screenshakeBegin = Date.now(); }

         var keys = new Array();
			var registerKey = function ( n, k ) { keys.push ( { name: n, key: k, state: undefined } ); };

			var key = function ( name ) {
				var result = 0;
				for ( i = 0; i < keys.length; i++ )
					if ( keys[i].name == name ) result = result || keys[i].state;
				return result;
			}

			document.onkeydown = function ( e ) {
				for ( var i = 0; i < keys.length; i++ )
					if ( e.which == keys[i].key ) keys[i].state = 1;
			}

			document.onkeyup = function ( e ) {
				for ( var i = 0; i < keys.length; i++ )
					if ( e.which == keys[i].key ) keys[i].state = 0;
			}

         var setup = function ( ) {
            canvas = document.getElementById ( "canvas" );
            context = canvas.getContext ( "2d" );

            radius = Math.max ( canvas.width, canvas.height ) * radiusFactor;

            setInterval ( draw, 1000 / fps );
            setInterval ( update, 1000 / fps );

            bgColor = $("body").css("background-color");
            obstColor = bgColor;

            match.setup ();

            document.onkeydown = function ( e ) {
               if ( e.which == 82 ) match.setup();
               if ( e.which == 32 ) match.snake.rotate *= -1;
            }

            document.onmousedown = function ( e ) { match.snake.rotate *= -1; }

            if ( localStorage.bestScore == undefined ) localStorage.bestScore = 0;
         }

         var draw = function ( ) {
            context.save ( );
            context.translate ( screenshake, 0 );

				context.fillStyle = bgColor;
				context.fillRect ( 0, 0, canvas.width, canvas.height );

            context.translate ( canvas.width / 2, canvas.height / 2 );

				match.draw ( context );

            context.restore ( );

            context.fillStyle = scoreColor;
				context.font = scoreSize + "px Varela Round";
				context.textAlign = "start";
				context.fillText ( Math.round(match.scoreShow), 20, 10 + scoreSize );

            context.font = bestScoreSize + "px Varela Round";
            context.fillText ( "combo x" + match.combo, 10, scoreSize + 20 + bestScoreSize );
            context.fillText ( "best " + localStorage.bestScore, 0, scoreSize + 30 + 2*bestScoreSize );
         }

         var update = function ( ) {
            match.update ( 1 / fps );

            if ( screenshakeBegin > 0 ) {
					var t = Date.now() - screenshakeBegin;
					screenshake = screenshakeWidth * Math.exp(- t / 150 ) * ( Math.sin(t/30) + Math.cos(t/30) );
				}
         }
      </script>
   </head>

   <body onload="setup()">
   		<canvas width="640" height="640" id="canvas"></canvas>
   </body>
</html>
